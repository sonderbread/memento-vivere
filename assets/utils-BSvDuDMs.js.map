{"version":3,"file":"utils-BSvDuDMs.js","sources":["../../src/utils/timeUtils.js","../../src/utils/pointUtils.js","../../src/utils/storageUtils.js"],"sourcesContent":["/**\n * Time utility functions for timer operations\n */\n\n/**\n * Format seconds into MM:SS format\n * @param {number} seconds - Seconds to format\n * @returns {string} Formatted time string\n */\nexport function formatTime(seconds) {\n    const mins = Math.floor(Math.abs(seconds) / 60);\n    const secs = Math.floor(Math.abs(seconds) % 60);\n    const sign = seconds < 0 ? '-' : '';\n    return `${sign}${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Calculate elapsed time for a running timer\n * @param {number} startTime - Timer start timestamp\n * @param {boolean} isPaused - Whether timer is paused\n * @param {number} pausedElapsed - Previously elapsed time when paused\n * @returns {number} Elapsed seconds\n */\nexport function calculateElapsedTime(startTime, isPaused, pausedElapsed = 0) {\n    if (isPaused) {\n        return pausedElapsed;\n    }\n    return Math.floor((Date.now() - startTime) / 1000) + pausedElapsed;\n}\n\n/**\n * Calculate display time for countdown timers\n * @param {number} totalSeconds - Total countdown duration\n * @param {number} elapsedSeconds - Elapsed time\n * @returns {number} Remaining seconds\n */\nexport function calculateCountdownTime(totalSeconds, elapsedSeconds) {\n    return Math.max(0, totalSeconds - elapsedSeconds);\n}\n\n/**\n * Parse time input (MM:SS or just minutes) into seconds\n * @param {string} timeInput - Time string to parse\n * @returns {number} Total seconds\n */\nexport function parseTimeInput(timeInput) {\n    if (!timeInput) return 0;\n\n    const parts = timeInput.split(':');\n    if (parts.length === 1) {\n        // Just minutes\n        return parseInt(parts[0], 10) * 60 || 0;\n    } else if (parts.length === 2) {\n        // MM:SS format\n        const minutes = parseInt(parts[0], 10) || 0;\n        const seconds = parseInt(parts[1], 10) || 0;\n        return minutes * 60 + seconds;\n    }\n\n    return 0;\n}\n\n/**\n * Convert seconds to MM:SS input format\n * @param {number} seconds - Seconds to convert\n * @returns {string} MM:SS format string\n */\nexport function secondsToTimeInput(seconds) {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Check if a timer has completed (for countdown timers)\n * @param {number} totalSeconds - Total duration\n * @param {number} elapsedSeconds - Elapsed time\n * @returns {boolean} Whether timer is complete\n */\nexport function isTimerComplete(totalSeconds, elapsedSeconds) {\n    return elapsedSeconds >= totalSeconds;\n}","/**\n * Point calculation utilities\n */\n\n/**\n * Calculate points earned for a completed timer activity\n * @param {Object} activity - Activity object\n * @param {number} elapsedSeconds - Time spent on activity\n * @returns {number} Points earned\n */\nexport function calculatePoints(activity, elapsedSeconds) {\n    if (activity.mode === 'single') {\n        return activity.points || 0;\n    }\n\n    const minutes = elapsedSeconds / 60;\n    const basePoints = minutes * (activity.rate || 1);\n\n    // Apply type multiplier (credit = positive, debit = negative)\n    return activity.type === 'credit' ? basePoints : -basePoints;\n}\n\n/**\n * Calculate points for a single-completion activity\n * @param {Object} activity - Activity object\n * @returns {number} Points for completion\n */\nexport function calculateSingleActivityPoints(activity) {\n    const points = activity.points || 0;\n    return activity.type === 'credit' ? points : -points;\n}\n\n/**\n * Format points with appropriate sign and precision\n * @param {number} points - Points to format\n * @returns {string} Formatted points string\n */\nexport function formatPoints(points) {\n    const sign = points >= 0 ? '+' : '';\n    return `${sign}${Math.round(points * 100) / 100}`;\n}\n\n/**\n * Calculate balance change for an activity completion\n * @param {Object} activity - Activity object\n * @param {number} elapsedSeconds - Time spent (for timer activities)\n * @returns {number} Balance change amount\n */\nexport function calculateBalanceChange(activity, elapsedSeconds = 0) {\n    if (activity.mode === 'single') {\n        return calculateSingleActivityPoints(activity);\n    } else {\n        return calculatePoints(activity, elapsedSeconds);\n    }\n}\n\n/**\n * Get activity rate display text\n * @param {Object} activity - Activity object\n * @returns {string} Rate display text\n */\nexport function getActivityRateDisplay(activity) {\n    if (activity.mode === 'single') {\n        return `${activity.points} pts`;\n    }\n    return `${activity.rate} pts/min`;\n}\n\n/**\n * Validate activity points/rate values\n * @param {Object} activity - Activity object to validate\n * @returns {Object} Validation result with isValid and errors\n */\nexport function validateActivityPoints(activity) {\n    const errors = [];\n\n    if (activity.mode === 'single') {\n        if (!activity.points || activity.points < 1) {\n            errors.push('Single activities must have at least 1 point');\n        }\n    } else {\n        if (!activity.rate || activity.rate < 0.1) {\n            errors.push('Timer activities must have at least 0.1 points per minute');\n        }\n    }\n\n    return {\n        isValid: errors.length === 0,\n        errors\n    };\n}","/**\n * Local storage utilities for data persistence\n */\n\n// Storage keys\nexport const STORAGE_KEYS = {\n    TASK_TIMER_DATA: 'taskTimerData',\n    DARK_MODE: 'memento-darkMode',\n    HIDE_BALANCE: 'memento-hideBalance',\n    ONBOARDING_SEEN: 'memento-onboarding-seen'\n};\n\n/**\n * Save data to localStorage with error handling\n * @param {string} key - Storage key\n * @param {any} data - Data to save\n * @returns {boolean} Success status\n */\nexport function saveToStorage(key, data) {\n    try {\n        localStorage.setItem(key, JSON.stringify(data));\n        return true;\n    } catch (error) {\n        console.error('Error saving to localStorage:', error);\n        return false;\n    }\n}\n\n/**\n * Load data from localStorage with error handling\n * @param {string} key - Storage key\n * @param {any} defaultValue - Default value if not found\n * @returns {any} Loaded data or default value\n */\nexport function loadFromStorage(key, defaultValue = null) {\n    try {\n        const item = localStorage.getItem(key);\n        if (item === null) return defaultValue;\n        return JSON.parse(item);\n    } catch (error) {\n        console.error('Error loading from localStorage:', error);\n        return defaultValue;\n    }\n}\n\n/**\n * Remove data from localStorage\n * @param {string} key - Storage key\n * @returns {boolean} Success status\n */\nexport function removeFromStorage(key) {\n    try {\n        localStorage.removeItem(key);\n        return true;\n    } catch (error) {\n        console.error('Error removing from localStorage:', error);\n        return false;\n    }\n}\n\n/**\n * Save main app data (activities, balance, timers, logs)\n * @param {Object} data - App data object\n * @returns {boolean} Success status\n */\nexport function saveAppData(data) {\n    return saveToStorage(STORAGE_KEYS.TASK_TIMER_DATA, data);\n}\n\n/**\n * Load main app data\n * @param {Object} defaultData - Default data structure\n * @returns {Object} Loaded app data\n */\nexport function loadAppData(defaultData = {}) {\n    return loadFromStorage(STORAGE_KEYS.TASK_TIMER_DATA, defaultData);\n}\n\n/**\n * Save dark mode preference\n * @param {boolean} isDarkMode - Dark mode enabled\n * @returns {boolean} Success status\n */\nexport function saveDarkMode(isDarkMode) {\n    return saveToStorage(STORAGE_KEYS.DARK_MODE, isDarkMode);\n}\n\n/**\n * Load dark mode preference\n * @returns {boolean} Dark mode preference\n */\nexport function loadDarkMode() {\n    return loadFromStorage(STORAGE_KEYS.DARK_MODE, true);\n}\n\n/**\n * Save hide balance preference\n * @param {boolean} hideBalance - Hide balance enabled\n * @returns {boolean} Success status\n */\nexport function saveHideBalance(hideBalance) {\n    return saveToStorage(STORAGE_KEYS.HIDE_BALANCE, hideBalance);\n}\n\n/**\n * Load hide balance preference\n * @returns {boolean} Hide balance preference\n */\nexport function loadHideBalance() {\n    return loadFromStorage(STORAGE_KEYS.HIDE_BALANCE, false);\n}\n\n/**\n * Save onboarding completion status\n * @param {boolean} seen - Whether onboarding was seen\n * @returns {boolean} Success status\n */\nexport function saveOnboardingSeen(seen) {\n    return saveToStorage(STORAGE_KEYS.ONBOARDING_SEEN, seen);\n}\n\n/**\n * Check if onboarding was seen\n * @returns {boolean} Onboarding seen status\n */\nexport function hasSeenOnboarding() {\n    return loadFromStorage(STORAGE_KEYS.ONBOARDING_SEEN, false);\n}\n\n/**\n * Check if this is the user's first visit\n * @returns {boolean} True if first visit\n */\nexport function isFirstVisit() {\n    return !hasSeenOnboarding();\n}\n\n/**\n * Clear all app data (for reset functionality)\n * @returns {boolean} Success status\n */\nexport function clearAllData() {\n    try {\n        Object.values(STORAGE_KEYS).forEach(key => {\n            localStorage.removeItem(key);\n        });\n        return true;\n    } catch (error) {\n        console.error('Error clearing app data:', error);\n        return false;\n    }\n}"],"names":["formatTime","seconds","mins","Math","floor","abs","secs","toString","padStart","calculateElapsedTime","startTime","isPaused","pausedElapsed","Date","now","calculateCountdownTime","totalSeconds","elapsedSeconds","max","isTimerComplete","formatPoints","points","round","calculateBalanceChange","activity","mode","type","calculateSingleActivityPoints","basePoints","rate","calculatePoints","STORAGE_KEYS","saveToStorage","key","data","localStorage","setItem","JSON","stringify","error","console","loadFromStorage","defaultValue","item","getItem","parse","saveAppData","loadAppData","defaultData","saveDarkMode","isDarkMode","loadDarkMode","saveHideBalance","hideBalance","loadHideBalance"],"mappings":"AASO,SAASA,EAAWC,GACvB,MAAMC,EAAOC,KAAKC,MAAMD,KAAKE,IAAIJ,GAAW,IACtCK,EAAOH,KAAKC,MAAMD,KAAKE,IAAIJ,GAAW,IAE5C,MAAO,GADMA,EAAU,EAAI,IAAM,KAChBC,EAAKK,WAAWC,SAAS,EAAG,QAAQF,EAAKC,WAAWC,SAAS,EAAG,MACrF,CASO,SAASC,EAAqBC,EAAWC,EAAUC,EAAgB,GACtE,OAAID,EACOC,EAEJT,KAAKC,OAAOS,KAAKC,MAAQJ,GAAa,KAAQE,CACzD,CAQO,SAASG,EAAuBC,EAAcC,GACjD,OAAOd,KAAKe,IAAI,EAAGF,EAAeC,EACtC,CAyCO,SAASE,EAAgBH,EAAcC,GAC1C,OAAOA,GAAkBD,CAC7B,CC5CO,SAASI,EAAaC,GAEzB,MAAO,GADMA,GAAU,EAAI,IAAM,KAChBlB,KAAKmB,MAAe,IAATD,GAAgB,KAChD,CAQO,SAASE,EAAuBC,EAAUP,EAAiB,GAC9D,MAAsB,WAAlBO,EAASC,KAtBV,SAAuCD,GAC1C,MAAMH,EAASG,EAASH,QAAU,EAClC,MAAyB,WAAlBG,EAASE,KAAoBL,GAAUA,CAClD,CAoBeM,CAA8BH,GAxCtC,SAAyBA,EAAUP,GACtC,GAAsB,WAAlBO,EAASC,KACT,OAAOD,EAASH,QAAU,EAG9B,MACMO,EADUX,EAAiB,IACHO,EAASK,MAAQ,GAG/C,MAAyB,WAAlBL,EAASE,KAAoBE,GAAcA,CACtD,CAgCeE,CAAgBN,EAAUP,EAEzC,CCjDO,MAAMc,EACQ,gBADRA,EAEE,mBAFFA,EAGK,sBAUX,SAASC,EAAcC,EAAKC,GAC/B,IAEI,OADAC,aAAaC,QAAQH,EAAKI,KAAKC,UAAUJ,KAClC,CACX,OAASK,GAEL,OADAC,QAAQD,MAAM,gCAAiCA,IACxC,CACX,CACJ,CAQO,SAASE,EAAgBR,EAAKS,EAAe,MAChD,IACI,MAAMC,EAAOR,aAAaS,QAAQX,GAClC,OAAa,OAATU,EAAsBD,EACnBL,KAAKQ,MAAMF,EACtB,OAASJ,GAEL,OADAC,QAAQD,MAAM,mCAAoCA,GAC3CG,CACX,CACJ,CAsBO,SAASI,EAAYZ,GACxB,OAAOF,EAAcD,EAA8BG,EACvD,CAOO,SAASa,EAAYC,EAAc,IACtC,OAAOP,EAAgBV,EAA8BiB,EACzD,CAOO,SAASC,EAAaC,GACzB,OAAOlB,EAAcD,EAAwBmB,EACjD,CAMO,SAASC,IACZ,OAAOV,EAAgBV,GAAwB,EACnD,CAOO,SAASqB,EAAgBC,GAC5B,OAAOrB,EAAcD,EAA2BsB,EACpD,CAMO,SAASC,IACZ,OAAOb,EAAgBV,GAA2B,EACtD"}